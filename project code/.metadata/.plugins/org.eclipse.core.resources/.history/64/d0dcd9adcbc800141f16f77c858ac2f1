import java.util.Date;
import java.util.LinkedList;

import distributed.systems.das.BattleField;
import distributed.systems.das.units.Unit;


public class TrailingState
{
	LinkedList<Move> moves;
	TrailingState firstMoreRecentState;
	Date delayDelta;
	BattleField currentState;
	
	public TrailingState(Date delayDelta, TrailingState firstMoreRecentState, BattleField initialState)
	{
		//initialization
		this.delayDelta = delayDelta;
		this.firstMoreRecentState = firstMoreRecentState;
		this.currentState = initialState.clone(); // we need a deep-copy method for BattleField
		moves= new LinkedList<Move>();
	}
	
	public void insertMove(Move m)
	{
		boolean conflictFound = false;
		long timeDifferenceBetweenConflicts = 0;
		int consideringPosition = 0;

		// We look though the list trying to find the position to put 'm'. If we find that position, we break. 
		// If we don't, we finish the loop and put 'm' at the end of the list.
		for(consideringPosition = 0; consideringPosition<moves.size(); consideringPosition++)
		{
			Move listedMove = moves.get(consideringPosition);
			if(m.earlierThan(listedMove))
			{
				break;
			}
			else
			{
				if(listedMove.conflictsWith(m))
				{
					conflictFound = true;
					timeDifferenceBetweenConflicts = listedMove.executionTimeDifference(m);
				}
			}
		}
		moves.add(consideringPosition, m);
		
		// test whether a rollback is required by:
		// first testing whether a conflict was discovered when inserting this move in the list.
		// if so whether the time-difference in the conflict was so great that the first more recent trailing state hasn't caught the conflict.
		// if so, do a sanity check whether we are the most recent trailing  state (by  testing whether 'firstMoreRecentState' is null).
		if(conflictFound 
				&& (delayDelta.getTime() - firstMoreRecentState.delayDelta.getTime() < timeDifferenceBetweenConflicts) 
				&& firstMoreRecentState != null)
		{
			firstMoreRecentState.rollBack(currentState, moves);
		}
	}
	
	//perform rollback
	@SuppressWarnings("unchecked")
	public void rollBack(BattleField rollbackState, LinkedList<Move> movesToBeDone)
	{
		this.currentState = rollbackState.clone(); //we need a cloning method for Battlefield.
		this.moves = (LinkedList<Move>)movesToBeDone.clone();
		// Note: as the moves are ordered chronologically in the time to be executed, we can stop as soon as we find a move that we can no longer execute right away.
		for(int i = 0; i < moves.size();i++)
		{
			Move moveConsidered = moves.get(i);
			if(moveConsidered.canBeExecutedNow(delayDelta))
			{
				moveConsidered.execute(currentState);
				moves.remove(i--);
			}
			else
			{
				break;
			}
		}
		
		// A rollback needs to be applied to all even more recent states.
		// The more recent state can start recalculating from this trailing state's position.
		if(firstMoreRecentState != null)
		{
			firstMoreRecentState.rollBack(currentState, moves);
		}
	}
}


//beschrijft een move-opdracht, inclusief timestamp wanneer die uitgevoerd moet worden.
// Note: Move-objects are used in multiple Trailing States at the same time, 
//       so after creation the fields need to be read-only.
public class Move
{
	Date executionTime;
	Unit mover;
	int targetX, targetY;
	Action action;
	
	public Move(Unit mover, int targetX, int targetY, Action action, Date executionTime)
	{
		this.executionTime = executionTime;
		this.mover = mover;
		this.targetX = targetX;
		this.targetY = targetY;
		this.action = action;
	}
	
	//tests whether this move needs to be applied earlier than the given move.
	public boolean earlierThan(Move m)
	{
		return executionTime.before(m.executionTime);
	}
	
	public boolean canBeExecutedNow(Date delay)
	{
		// Note: 'new Date()' gives the current time.
		// So we test: (executionTime + delay) < currentTime
		return (executionTime.getTime() + delay.getTime()) < (new Date()).getTime();
	}
	
	//get the absolute time difference between the execution times of these 2 moves in milliseconds.
	public long executionTimeDifference(Move m)
	{
		return Math.abs(executionTime.getTime() - m.executionTime.getTime());
	}
	
	//tests whether this moves conflicts with the given move. So if applying them in different order could result in a different gamestate.
	public boolean conflictsWith(Move m)
	{
		
	}
	
	// Apply the move to the state.
	// This does not check whether the move is valid!
	public void execute(BattleField beforeState)
	{
		
	}
	
	public enum Action
	{
		Attack, Heal, Move
	};
}